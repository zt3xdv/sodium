'use strict';

var crypto = require('crypto');
var fs = require('fs');
var promises = require('fs/promises');
var module$1 = require('module');
var path = require('path');
var commonjs = require('@rollup/plugin-commonjs');
var pluginNodeResolve = require('@rollup/plugin-node-resolve');
var replace = require('@rollup/plugin-replace');
var rollup = require('rollup');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
var rollup__namespace = /*#__PURE__*/_interopNamespaceDefault(rollup);

/**
 * Cache that stores data in a JSON file.
 */
class Cache {
  /**
   * @param {string} cacheDir
   * @param {string} name
   */
  constructor(cacheDir, name) {
    this._cacheDir = cacheDir;
    this._cacheFile = `${cacheDir}/${name}.json`;
    this._cache = null;
  }

  /**
   * Read an entry from the cache, or return `null` if the existing entry's
   * version does not match `version`.
   *
   * @param {string} key
   * @param {string} version
   */
  async get(key, version) {
    const cache = await this._readCache();

    // TODO - Prevent use of standard object properties as keys;
    const entry = cache[key];
    if (entry?.version !== version) {
      return null;
    }

    return entry.value;
  }

  /**
   * Write an entry to the cache. Writes are not flush to disk until {@link flush}
   * is called.
   *
   * @param {string} key
   * @param {string} version
   * @param {any} value
   */
  async set(key, version, value) {
    const cache = await this._readCache();
    cache[key] = { version, value };
  }

  /**
   * Flush pending cache updates to disk.
   */
  async flush() {
    if (!this._cache) {
      this._cache = {};
    }
    await promises.writeFile(this._cacheFile, Buffer.from(JSON.stringify(this._cache)));
  }

  async _readCache() {
    if (!this._cache) {
      try {
        await promises.mkdir(this._cacheDir, { recursive: true });
        const fileData = await promises.readFile(this._cacheFile);
        this._cache = JSON.parse(fileData.toString());
      } catch {
        this._cache = {};
      }
    }
    return this._cache;
  }
}

/**
 * @param {string[]} files
 */
function createVersionHash(files) {
  const hash = crypto.createHash("md5");
  for (let file of files) {
    const data = fs.readFileSync(file);
    hash.update(data);
  }
  return hash.digest("hex");
}

/**
 * @param {*} plugin
 * @return {Function}
 */
function getHandler(plugin) {
  return plugin.handler || plugin;
}

/**
 * @typedef PluginCacheConfig
 * @prop {string} cacheDir - Directory to write cache files to
 * @prop {string} versionHash - A version identifier for dependencies of the
 *   plugin's output. This is used together with item-specific data to determine
 *   whether existing cache entries are valid.
 */

/**
 * Wrap a Rollup plugin to add caching to various hooks.
 *
 * @param {import("rollup").Plugin} plugin
 * @param {PluginCacheConfig} config
 * @return {import("rollup").Plugin}
 */
function cachingPlugin(plugin, { cacheDir, versionHash }) {
  const cache = new Cache(cacheDir, plugin.name);

  /** @param {Buffer|string} data */
  const getCacheVersion = (data) => {
    const hash = crypto.createHash("md5");
    hash.update(versionHash);
    hash.update(data);
    return hash.digest("hex");
  };

  /** @type {import("rollup").Plugin} */
  const cachedPlugin = {
    ...plugin,

    name: `cached(${plugin.name})`,

    async buildStart(options) {
      if (plugin.buildStart) {
        await getHandler(plugin.buildStart).call(this, options);
      }
    },

    async buildEnd(error) {
      await cache.flush();
      if (plugin.buildEnd) {
        await getHandler(plugin.buildEnd).call(this, error);
      }
    },

    async resolveId(id, importer, options) {
      if (!plugin.resolveId) {
        return null;
      }

      const cacheKey = `resolveId:${id},${importer}`;
      const version = "default";
      const cachedResult = await cache.get(cacheKey, version);
      if (cachedResult !== null) {
        return cachedResult;
      }
      const result = await getHandler(plugin.resolveId).call(
        this,
        id,
        importer,
        options
      );
      await cache.set(cacheKey, version, result);
      return result;
    },

    async load(id) {
      if (!plugin.load) {
        return null;
      }

      const cacheKey = `load:${id}`;
      const version = "default";
      const cachedResult = await cache.get(cacheKey, version);
      if (cachedResult !== null) {
        return cachedResult;
      }
      const result = await getHandler(plugin.load).call(this, id);
      await cache.set(cacheKey, version, result);
      return result;
    },

    async transform(code, id) {
      if (!plugin.transform) {
        return null;
      }
      const version = getCacheVersion(code);
      const cacheKey = `transform:${id}`;
      const cachedResult = await cache.get(cacheKey, version);
      if (cachedResult !== null) {
        return cachedResult;
      }
      const result = await getHandler(plugin.transform).call(this, code, id);
      await cache.set(cacheKey, version, result);
      return result;
    },
  };

  return cachedPlugin;
}

const defaultDependencies = ["package.json", "package-lock.json", "yarn.lock"];

/**
 * Wrap a Rollup bundle configuration to enable selective caching of plugin build hooks.
 *
 * @param {import("rollup").RollupOptions} buildConfig
 * @param {object} options
 *   @param {string} options.cacheRoot
 *   @param {string[]} options.dependencies
 *   @param {string[]} options.cachePlugins
 */
function addPluginCachingToConfig(
  buildConfig,
  { cacheRoot, dependencies, cachePlugins }
) {
  const versionHash = createVersionHash([
    ...defaultDependencies.filter((path) => fs.existsSync(path)),
    ...dependencies,
  ]);

  const cachingPlugins =
    // @ts-ignore
    buildConfig.plugins?.map((plugin) => {
      if (!plugin) {
        return plugin;
      }
      const config = cachePlugins.includes(plugin.name) ? {} : null;
      if (!config) {
        return plugin;
      }
      return cachingPlugin(plugin, {
        cacheDir: cacheRoot,
        // TODO - Add plugin-specific files (eg. Babel config) to version hash.
        versionHash,
        ...config,
      });
    }) ?? [];

  return {
    ...buildConfig,
    plugins: [...cachingPlugins],
  };
}

/**
 * @param {string} dir
 * @param {string} name
 */
function bundlePath(dir, name) {
  return `${dir}/${name}.bundle.js`;
}

/**
 * Return the relative path from one ES bundle to another, suitable for
 * use in an `import` statement.
 *
 * @param {string} from
 * @param {string} to
 */
function relativeImportPath(from, to) {
  const relativePath = path__namespace.relative(path__namespace.dirname(from), to);
  if (relativePath.startsWith(".")) {
    return relativePath;
  } else {
    return `./${relativePath}`;
  }
}

/**
 * Return Rollup configuration for bundling an NPM package as an ESM bundle.
 *
 * @param {string} name
 * @param {string} dir
 * @param {string[]} deps - List of NPM dependencies which are also being prebuilt
 *   in the current build. This is used to ensure that any common dependencies
 *   between bundles all refer to the same bundle. eg. For example if building
 *   an application which depends on React as well as a library of React components,
 *   both the application and the library must use the same copy of React.
 * @return {import("rollup").RollupOptions}
 */
function bundleConfig(name, dir, deps) {
  return {
    input: name,
    output: {
      file: bundlePath(dir, name),
      format: "es",
      sourcemap: true,
      paths: Object.fromEntries(
        deps.map((dep) => [
          dep,
          relativeImportPath(bundlePath(dir, name), bundlePath(dir, dep)),
        ])
      ),
    },
    external: deps.filter((d) => d !== name),
    plugins: [
      replace({
        preventAssignment: true,
        values: {
          "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV),
        },
      }),
      pluginNodeResolve.nodeResolve(),
      commonjs({ esmExternals: true }),
    ],
  };
}

/**
 * Build an NPM dependency as a bundle in `dir`.
 *
 * @param {Record<string, number>} npmBundles - Map of npm dependency names to
 *   timestamps of previous bundle build
 * @param {string} dir - Directory which bundles should be generated in
 */
async function buildNPMBundles(npmBundles, dir) {
  const npmBundleList = Object.entries(npmBundles)
    .filter(([name, timestamp]) => {
      try {
        const outputTimestamp = fs.statSync(bundlePath(dir, name)).mtimeMs;
        if (outputTimestamp >= timestamp) {
          return false;
        }
        return true;
      } catch (err) {
        return true;
      }
    })
    .map(([name]) => name)
    .sort();

  if (npmBundleList.length === 0) {
    return;
  }

  console.log(`Building NPM bundles: ${npmBundleList.join(", ")}`);

  const configs = npmBundleList.map((name) =>
    bundleConfig(name, dir, npmBundleList)
  );
  await Promise.all(
    configs.map(async (config) => {
      const bundle = await rollup__namespace.rollup({
        ...config,
        onwarn: console.log,
      });
      await bundle.write(
        /** @type {import("rollup").OutputOptions} */ (config.output)
      );
    })
  );
}

const require$1 = module$1.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)));

/**
 * Return the path of the `package.json` file associated with a given module ID.
 *
 * The module ID may be the name of a package or a module within a package,
 * in which case the containing package's package.json is found.
 *
 * @param {string} moduleID
 */
function getPackageJSONPath(moduleID) {
  const entryPoint = require$1.resolve(moduleID);
  let dir = path__namespace.dirname(entryPoint);
  let relativePackagePath = "package.json";
  while (dir !== "/" && !fs.existsSync(`${dir}/${relativePackagePath}`)) {
    dir = path__namespace.dirname(dir);
  }
  return `${dir}/${relativePackagePath}`;
}

/**
 * Get the last-modified timestamp of the package.json file associated with
 * a module.
 *
 * @param {string} moduleID
 */
function getPackageTimestamp(moduleID) {
  const packagePath = getPackageJSONPath(moduleID);
  try {
    const stats = fs.statSync(packagePath);
    return stats.mtimeMs;
  } catch (err) {
    throw new Error(`Failed to get package version for "${moduleID}"`);
  }
}

/**
 * Wrap a Rollup bundle configuration to enable prebuilding of npm dependencies.
 *
 * @param {import("rollup").RollupOptions} buildConfig
 * @param {object} options
 *   @param {string} options.cacheRoot
 *   @param {string} options.prebuildDir
 *   @param {(string|RegExp)[]} options.prebuild
 */
function addPrebuildingToConfig(
  buildConfig,
  { cacheRoot, prebuildDir, prebuild }
) {
  /**
   * Module IDs of npm dependencies that have been discovered in this build
   * that should be prebuilt and marked as external within the output bundle.
   *
   * @type {Set<string>}
   */
  const externalDependencies = new Set();

  /**
   * @param {string} id
   * @param {string|undefined} parentId
   * @param {boolean} isResolved
   * @return {boolean}
   */
  const shouldMakeExternal = (id, parentId, isResolved) => {
    if (
      // Is this a local (non-npm) import?
      !id.startsWith(".") &&
      !id.startsWith("/") &&
      // Is prebuilding enabled for this package?
      prebuild.some((pattern) => id.match(pattern))
    ) {
      externalDependencies.add(id);
      return true;
    }

    // Fall back to original external function.
    // See https://rollupjs.org/guide/en/#external.
    const origExternal = buildConfig.external;
    if (!origExternal) {
      return false;
    }
    if (typeof origExternal === "function") {
      return !!origExternal(id, parentId, isResolved);
    } else if (Array.isArray(origExternal)) {
      return origExternal.some((pattern) => id.match(pattern));
    } else {
      return !!id.match(origExternal);
    }
  };

  /**
   * @param {string} id
   * @param {import("rollup").OptionsPaths} [origPaths]
   */
  const getOutputPath = (id, origPaths) => {
    let origPath;
    if (typeof origPaths === "function") {
      origPath = origPaths(id);
    } else if (origPaths) {
      origPath = origPaths[id];
    }
    if (origPath) {
      return origPath;
    }
    if (externalDependencies.has(id)) {
      return `${prebuildDir}/${id}.bundle.js`;
    }
    return id;
  };

  // TODO - Handle the case where `buildConfig.output` is an array.

  /** @type {import("rollup").OutputOptions} */
  const output = {
    ...buildConfig.output,
    paths: (id) =>
      getOutputPath(
        id,
        /** @type {import("rollup").OutputOptions} */ (buildConfig.output).paths
      ),
  };

  let outputDir;
  if (output.dir) {
    outputDir = output.dir;
  } else if (output.file) {
    outputDir = path__namespace.dirname(output.file);
  } else {
    throw new Error(
      `"output.dir" or "output.file" options must be specified in Rollup config to use prebuilding`
    );
  }

  const resolvedPrebuildDir = path__namespace.resolve(outputDir, prebuildDir);

  const buildExternalDeps = {
    name: "rollup-cache:build-external-deps",

    async buildEnd() {
      /** @type {Record<string, number>} */
      const depVersions = {};
      const deps = [...externalDependencies].sort();
      for (let dependency of deps) {
        depVersions[dependency] = getPackageTimestamp(dependency);
      }
      await buildNPMBundles(depVersions, resolvedPrebuildDir);
    },
  };

  return {
    ...buildConfig,
    output,
    external: shouldMakeExternal,
    plugins: [
      .../** @type {import("rollup").Plugin[]} */ (buildConfig.plugins),
      buildExternalDeps,
    ],
  };
}

/**
 * @typedef CacheConfig
 * @prop {string} name - Cache key for the current build. This should be an
 *   identifier that is unique for the Rollup configuration, such as its file path.
 * @prop {string} [cacheDir] - Location to write cache data to. Defaults to
 *   "node_modules/.cache/rollup-cache".
 * @prop {string[]} [dependencies] - A list of file paths to be checked before
 *   using existing cache data. If any of these files have changed since the
 *   previous build, the existing cache data will be discarded.
 * @prop {string[]} [cachePlugins] - A list of plugins name to cache. Defaults
 * to ["babel", "commonjs", "node-resolve"].
 * @prop {boolean} [enabled] - Whether to enable caching. By default this setting
 *   is true unless this is a production build, signalled by
 *   `process.env.NODE_ENV` being set to `production`.
 * @prop {string} [prebuildDir] - Directory in which to write pre-generated
 *   bundles for npm dependencies. Defaults to "./npm".
 * @prop {string[]} [prebuild] - List of npm dependencies to prebuild. Packages
 *   listed here will be bundled into ES modules and written to `prebuildDir`.
 *   References to these dependencies in other code will be replaced with
 *   imports using Rollup's `externals` config setting.
 */

/**
 * Wrap a Rollup configuration to enable caching and (optionally) prebuilding.
 *
 * @param {CacheConfig} cacheConfig
 * @param {import("rollup").RollupOptions} buildConfig
 * @return {import("rollup").RollupOptions}
 */
function cacheBuild(cacheConfig, buildConfig) {
  const {
    name,
    cacheDir = "node_modules/.cache/rollup-cache",
    dependencies = [],
    cachePlugins = ["babel", "commonjs", "node-resolve"],
    enabled = process.env.NODE_ENV !== "production",
    prebuild = [],
    prebuildDir = "./npm",
  } = cacheConfig;

  if (!enabled) {
    return buildConfig;
  }

  const cacheRoot = `${cacheDir}/${name}`;

  let wrappedConfig = addPluginCachingToConfig(buildConfig, {
    cacheRoot,
    dependencies,
    cachePlugins,
  });

  if (prebuild.length > 0) {
    wrappedConfig = addPrebuildingToConfig(wrappedConfig, {
      cacheRoot,
      prebuildDir,
      prebuild,
    });
  }

  return wrappedConfig;
}

exports.cacheBuild = cacheBuild;
